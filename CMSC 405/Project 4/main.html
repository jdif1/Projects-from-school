<!--
Jeff DiFatta
CMSC 405
5/10/2022

This is the code for the running engine project. The animation consists of 10 cylinders and a square that form an
engine block and pistons. The 10 pistons move up and down in the engine block. There is also an effusive light
overhead with a cone around the top of it and a cylinder attached to the cone to make it look like there is a shop
light hanging over the engine. The animation can be stopped or started with a button at the top of the screen, the
text in the button changes between STOP and START depending on what will happen when you hit the button.

The diskplay.HTML file that was provided in this week's lesson was used as a template.

I could not get the textures to work before the project was due, I have however left the code I wrote for the textures
in. This was in an effort to show my work and if possible, receive some feedback as to what I am currently missing.
-->

<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<head>
    <img id = "engine_surface" src ="engine surface.jpg" width="0" height="0">
    <img id = "piston_surface" src ="piston surface.jpg" width="0" height="0">

    <title>Engine Running</title>
    <style>
        body {
            background-color: #EEEEEE;
        }
        label {
            white-space: pre;
            margin-left: 25px;
        }
    </style>

    <script type="x-shader/x-vertex" id="vshader-source">
    attribute vec3 a_coords;
    attribute vec3 a_normal;
    attribute vec2 a_texCoords;
    varying vec2 v_texCoords;
    uniform mat4 modelview;
    uniform mat4 projection;
    varying vec3 v_normal;
    varying vec3 v_eyeCoords;
    void main() {
        vec4 coords = vec4(a_coords,1.0);
        vec4 eyeCoords = modelview * coords;
        gl_Position = projection * eyeCoords;
        v_normal = normalize(a_normal);
        v_eyeCoords = eyeCoords.xyz/eyeCoords.w;
        v_texCoords = a_texCoords;
    }
</script>

    <script type="x-shader/x-fragment" id="fshader-source">
    #ifdef GL_FRAGMENT_PRECISION_HIGH
       precision highp float;
    #else
       precision mediump float;
    #endif
    struct MaterialProperties {
        vec4 diffuseColor;
        vec3 specularColor;
        vec3 emissiveColor;
        float specularExponent;
    };
    varying vec2 v_texCoords;
    uniform sampler2D u_texture1;
    struct LightProperties {
        bool enabled;
        vec4 position;
        vec3 color;
    };
    uniform MaterialProperties material; // do two-sided lighting, but assume front and back materials are the same
    uniform LightProperties lights[2]; //changed from 4 to 2
    uniform mat3 normalMatrix;
    varying vec3 v_normal;
    varying vec3 v_eyeCoords;

    vec3 lightingEquation( LightProperties light, MaterialProperties material,
                                vec3 eyeCoords, vec3 N, vec3 V ) {
           // N is normal vector, V is direction to viewer.
        vec3 L, R; // Light direction and reflected light direction.
        if ( light.position.w == 0.0 ) {
            L = normalize( light.position.xyz );
        }
        else {
            L = normalize( light.position.xyz/light.position.w - v_eyeCoords );
        }
        if (dot(L,N) <= 0.0) {
            return vec3(0.0);
        }
        vec3 reflection = dot(L,N) * light.color * material.diffuseColor.rgb;
        R = -reflect(L,N);
        if (dot(R,V) > 0.0) {
            float factor = pow(dot(R,V),material.specularExponent);
            reflection += factor * material.specularColor * light.color;
        }
         return reflection;

    }
    void main() {
        vec2 texCoords = v_texCoords;
        vec3 normal = normalize( normalMatrix*v_normal );
        vec3 viewDirection = normalize( -v_eyeCoords);  // (Assumes a perspective projection.)
        vec3 color = material.emissiveColor;
        vec3 texColor1 = texture2D( u_texture1, texCoords).rgb;
        for (int i = 0; i < 2; i++) { //changed from 4 to 2
            if (lights[i].enabled) {
                if (gl_FrontFacing) {
                    color += lightingEquation( lights[i], material, v_eyeCoords,
                                                    normal, viewDirection);
                }
                else {
                    color += lightingEquation( lights[i], material, v_eyeCoords,
                                                    -normal, viewDirection);
                }
            }
        }

        gl_FragColor = vec4(color,material.diffuseColor.a);
    }
</script>
    <script src="gl-matrix-min.js"></script>
    <script src="trackball-rotator.js"></script>
    <script src="basic-object-models-IFS.js"></script>
    <script>

        "use strict";

        let u_texture1_location

        let gl;

        let a_coords_loc;
        let a_normal_loc;
        let a_texCoords_location;

        let u_modelview;
        let u_projection;
        let u_normalMatrix;

        let u_material;
        let u_lights;

        let projection = mat4.create();
        let modelview;
        let normalMatrix = mat3.create();

        let rotator;

        let frameNumber = 0;

        var sphere, cone, cylinder, cube;

        let matrixStack = [];

        let currentColor = [1,1,1,1];

        var textureObjects;

        var texturesLoaded = false;

        let textureURL =[
            "engine surface.jpg",
            "piston surface.jpg"
        ];

        let engineTexture = 0;

        let pistonTexture = 1;

        function loadTextures(){
            var loaded = 0;
            textureObjects = new Array((textureURL.length));
            for (var i = 0; i < textureURL.length; i++){
                load(i,textureURL[i]);
            }
            function load(textureNum, url){
                var img = new Image();
                img.onload = function (){
                    loaded++;
                    textureObjects[textureNum] = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, textureObjects[textureNum]);
                    try{
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                    } catch (e){
                        throw "Error. Could not load textures.";
                    }
                };
                gl.generateMipmap(gl.TEXTURE_2D);
                if (loaded === textureURL.length){
                    texturesLoaded = true;
                    draw();
                }
                img.src = url;
            }
        }
        function draw() {

            gl.clearColor(0,0,0,1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            mat4.perspective(projection, Math.PI/4, 1, 1, 50);
            gl.uniformMatrix4fv(u_projection, false, projection );

            modelview = rotator.getViewMatrix();

            lights();
            engine();
        }


        function lights() {

            gl.uniform1i( u_lights[0].enabled, 5 );
            gl.uniform4f( u_lights[0].position, 0,0,3,0 );
            gl.uniform3f( u_lights[0].color, 1.0,1.0,1.0 );

            //light bulb
            pushMatrix();
            mat4.translate(modelview,modelview,[0,3,0]);//
            mat4.scale(modelview,modelview,[0.8,0.8,0.8]);
            gl.uniform3f( u_material.emissiveColor, 0.7, 0.7, 0 );
            sphere.render();
            gl.uniform3f( u_material.emissiveColor, 0, 0, 0 );
            popMatrix();
        }

        function engine() {

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureObjects[engineTexture]);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);

            //Engine block
            pushMatrix();
            mat4.translate(modelview,modelview,[0,-5,0]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[9,6,5]);
            currentColor = [0.1,0.1,0.1,1];
            cube.render();
            popMatrix();

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, textureObjects[pistonTexture]);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);

            //Pistons
            pushMatrix();
            mat4.translate(modelview,modelview,[-3.4, -1 + Math.cos(frameNumber/15),-1.5]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1.5,1.5,1.4]);
            currentColor = [0.1,0.1,0.1,1];
            cylinder.render();
            popMatrix();

            pushMatrix();
            mat4.translate(modelview,modelview,[-3.4, -1 + Math.cos(frameNumber/15), 1.5]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1.5,1.5,1.4]);
            currentColor = [0.1,0.1,0.1,1];
            cylinder.render();
            popMatrix();

            pushMatrix();
            mat4.translate(modelview,modelview,[-1.7, -1 + Math.cos(frameNumber/15),-1.5]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1.5,1.5,1.4]);
            currentColor = [0.1,0.1,0.1,1];
            cylinder.render();
            popMatrix();

            pushMatrix();
            mat4.translate(modelview,modelview,[-1.7, -1 + Math.cos(frameNumber/15), 1.5]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1.5,1.5,1.4]);
            currentColor = [0.1,0.1,0.1,1];
            cylinder.render();
            popMatrix();

            pushMatrix();
            mat4.translate(modelview,modelview,[0.0, -1 + Math.cos(frameNumber/15),-1.5]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1.5,1.5,1.4]);
            currentColor = [0.1,0.1,0.1,1];
            cylinder.render();
            popMatrix();

            pushMatrix();
            mat4.translate(modelview,modelview,[0.0, -1 + Math.cos(frameNumber/15), 1.5]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1.5,1.5,1.4]);
            currentColor = [0.1,0.1,0.1,1];
            cylinder.render();
            popMatrix();

            pushMatrix();
            mat4.translate(modelview,modelview,[1.7, -1 + Math.cos(frameNumber/15),-1.5]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1.5,1.5,1.4]);
            currentColor = [0.1,0.1,0.1,1];
            cylinder.render();
            popMatrix();

            pushMatrix();
            mat4.translate(modelview,modelview,[1.7, -1 + Math.cos(frameNumber/15), 1.5]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1.5,1.5,1.4]);
            currentColor = [0.1,0.1,0.1,1];
            cylinder.render();
            popMatrix();

            pushMatrix();
            mat4.translate(modelview,modelview,[3.4, -1 + Math.cos(frameNumber/15),-1.5]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1.5,1.5,1.4]);
            currentColor = [0.1,0.1,0.1,1];
            cylinder.render();
            popMatrix();

            pushMatrix();
            mat4.translate(modelview,modelview,[3.4, -1 + Math.cos(frameNumber/15), 1.5]);
            mat4.rotate(modelview,modelview,(90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1.5,1.5,1.4]);
            currentColor = [0.1,0.1,0.1,1];
            cylinder.render();
            popMatrix();

            //cone for the light bulb
            pushMatrix();
            mat4.translate(modelview,modelview,[0.0, 3.2, 0.0]);
            mat4.rotate(modelview,modelview,(-90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[2,2,2]);
            cone.render();
            popMatrix();

            //connection to the ceiling for the light bulb
            pushMatrix();
            mat4.translate(modelview,modelview,[0.0, -1, 0.0]);
            mat4.rotate(modelview,modelview,(-90)/180*Math.PI,[1,0,0]);
            mat4.scale(modelview,modelview,[1,1,5]);
            cylinder.render();
            popMatrix();

        }

        function pushMatrix() {
            matrixStack.push( mat4.clone(modelview) );
        }

        function popMatrix() {
            modelview = matrixStack.pop();
        }

        function createModel(modelData, xtraTranslate) {

            var model = {};
            model.coordsBuffer = gl.createBuffer();
            model.normalBuffer = gl.createBuffer();
            model.indexBuffer = gl.createBuffer();
            model.texCoordsBuffer = gl.createBuffer();
            model.count = modelData.indices.length;

            if (xtraTranslate) {
                model.xtraTranslate = xtraTranslate;
            }
            else {
                model.xtraTranslate = null;
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, model.texCoordsBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexTextureCoords, gl.STATIC_DRAW);

            model.render = function() {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer);
                gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
                gl.vertexAttribPointer(a_normal_loc, 3, gl.FLOAT, false, 0, 0);
                gl.uniform4fv(u_material.diffuseColor, currentColor);
                if (this.xtraTranslate) {
                    pushMatrix();
                    mat4.translate(modelview,modelview,this.xtraTranslate);
                }
                gl.uniformMatrix4fv(u_modelview, false, modelview );
                mat3.normalFromMat4(normalMatrix, modelview);
                gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
                if (this.xtraTranslate) {
                    popMatrix();
                }
            }
            gl.enableVertexAttribArray(a_coords_loc);
            gl.enableVertexAttribArray(a_texCoords_location);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
            return model;
        }

        function createProgram(gl, vertexShaderID, fragmentShaderID) {
            function getTextContent( elementID ) {
                let element = document.getElementById(elementID);
                let node = element.firstChild;
                let str = "";
                while (node) {
                    if (node.nodeType === 3)
                        str += node.textContent;
                    node = node.nextSibling;
                }
                return str;
            }
            try {
                var vertexShaderSource = getTextContent( vertexShaderID );
                var fragmentShaderSource = getTextContent( fragmentShaderID );
            }
            catch (e) {
                throw "Error: Could not get shader source code from script elements.";
            }
            let vsh = gl.createShader( gl.VERTEX_SHADER );
            gl.shaderSource(vsh,vertexShaderSource);
            gl.compileShader(vsh);
            if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
                throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
            }
            let fsh = gl.createShader( gl.FRAGMENT_SHADER );
            gl.shaderSource(fsh, fragmentShaderSource);
            gl.compileShader(fsh);
            if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
                throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
            }
            let prog = gl.createProgram();
            gl.attachShader(prog,vsh);
            gl.attachShader(prog, fsh);
            gl.linkProgram(prog);
            if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
                throw "Link error in program:  " + gl.getProgramInfoLog(prog);
            }
            return prog;
        }

        function initGL() {
            let prog = createProgram(gl,"vshader-source","fshader-source");
            gl.useProgram(prog);
            gl.enable(gl.DEPTH_TEST);
            a_coords_loc =  gl.getAttribLocation(prog, "a_coords");
            a_normal_loc =  gl.getAttribLocation(prog, "a_normal");
            gl.enableVertexAttribArray(a_coords_loc);
            gl.enableVertexAttribArray(a_normal_loc);

            u_modelview = gl.getUniformLocation(prog, "modelview");
            u_projection = gl.getUniformLocation(prog, "projection");
            u_normalMatrix =  gl.getUniformLocation(prog, "normalMatrix");



            u_texture1_location =gl.getUniformLocation(prog, "u_texture1");
            gl.uniform1i(u_texture1_location, 0);


            u_material = {
                diffuseColor: gl.getUniformLocation(prog, "material.diffuseColor"),
                specularColor: gl.getUniformLocation(prog, "material.specularColor"),
                emissiveColor: gl.getUniformLocation(prog, "material.emissiveColor"),
                specularExponent: gl.getUniformLocation(prog, "material.specularExponent")
            };
            u_lights = new Array(2);
            for (var i = 0; i < 2; i++) {
                u_lights[i] = {
                    enabled: gl.getUniformLocation(prog, "lights[" + i + "].enabled"),
                    position: gl.getUniformLocation(prog, "lights[" + i + "].position"),
                    color: gl.getUniformLocation(prog, "lights[" + i + "].color")
                };
            }
            gl.uniform3f( u_material.specularColor, 0.1, 0.1, 0.1 );
            gl.uniform1f( u_material.specularExponent, 16 );
            gl.uniform3f( u_material.emissiveColor, 0, 0, 0);

            for (var i = 1; i < 2; i++) {
                gl.uniform1i( u_lights[i].enabled, 0 );
                gl.uniform4f( u_lights[i].position, 0, 0, 1, 0 );
                gl.uniform3f( u_lights[i].color, 1,1,1 );
            }

            loadTextures();

        }

        var animating = false;

        function frame() {
            if (animating) {
                frameNumber += 1;
                draw();
                requestAnimationFrame(frame);
            }
        }

        function startStopAnimation(){
            if (animating === false){
                animating = true;
                setAnimating(animating)
                requestAnimationFrame(frame);
                document.getElementById("ignition").value = "STOP"
            } else{
                animating = false;
                setAnimating(animating);
                document.getElementById("ignition").value = "START"
            }

        }

        function setAnimating(run) {
            if (run !== animating) {
                animating = run;
                if (animating)
                    requestAnimationFrame(frame);
            }
        }

        function init() {
            try {
                var canvas = document.getElementById("webglcanvas");
                gl = canvas.getContext("webgl") ||
                    canvas.getContext("experimental-webgl");
                if ( ! gl ) {
                    throw "Browser does not support WebGL";
                }
            }
            catch (e) {
                document.getElementById("message").innerHTML =
                    "<p>Sorry, could not get a WebGL graphics context.</p>";
                return;
            }
            try {
                initGL();
            }
            catch (e) {
                document.getElementById("message").innerHTML =
                    "<p>Sorry, could not initialize the WebGL graphics context:" + e + "</p>";
                return;
            }
            sphere = createModel(uvSphere(1));
            cone = createModel(uvCone(),[0,0,.5]);
            cylinder = createModel(uvCylinder(),[0,0,1.5]);
            cube = createModel(cube());

            rotator = new TrackballRotator(canvas,function() {
                if (!animating)
                    draw();
            },17,[0,1,2]);
            draw();
        }

    </script>
</head>
<body onload="init()">

<h2>Running Engine</h2>
<noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>
<p>
    <input type = "button" id="ignition" onclick = "startStopAnimation()" value = "START">

</p>

<div>

    <canvas width=800 height=800 id="webglcanvas" style="background-color:blue"></canvas>

</div>
</body>
</html>